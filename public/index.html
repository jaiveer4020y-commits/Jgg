<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Netflix ArtPlayer</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="stylesheet" href="https://unpkg.com/artplayer@5.3.0/dist/artplayer.css" />
<script src="https://unpkg.com/artplayer@5.3.0/dist/artplayer.js"></script>
<script src="https://unpkg.com/hls.js@1.5.17/dist/hls.min.js"></script>

<style>
html,body{
    margin:0;
    padding:0;
    width:100%;
    height:100%;
    background:#000;
}

/* PLAYER */
#player{
    position:relative;
    width:100%;
    height:100%;
    background:#000;
    overflow:hidden;
}

/* ================= NETFLIX SPINNER ================= */
.netflix-spinner{
    position:absolute;
    inset:0;
    display:none;
    align-items:center;
    justify-content:center;
    background:#000;
    z-index:999999;
}
.netflix-spinner img{
    width:64px;
    height:64px;
}

/* ================= SUBTITLE RENDER ================= */
.subtitle-container{
    position:absolute;
    width:90%;
    left:50%;
    bottom:14%;
    transform:translateX(-50%);
    display:flex;
    justify-content:center;
    z-index:999998;
    pointer-events:none;
}
.subtitle-container p{
    font-size:23px;
    color:#f5f5f5;
    text-align:center;
    white-space:pre-wrap;
    text-shadow:
        0 2px 4px rgba(0,0,0,.9),
        0 0 2px rgba(0,0,0,.9);
}
</style>
</head>

<body>

<div id="player">
    <!-- NETFLIX SPINNER -->
    <div class="netflix-spinner" id="spinner">
        <img src="https://assets.nflxext.com/en_us/pages/wiplayer/site-spinner.png" />
    </div>

    <!-- SUBTITLE -->
    <div class="subtitle-container">
        <p id="subtitleText"></p>
    </div>
</div>

<script>
/* ================= CONFIG ================= */
const PROXY = "https://workingg.vercel.app/api/proxy?url=";
const STREAM_API = "https://u-1-1azw.onrender.com/api/get-stream";
const SUB_API = "https://sub.wyzie.ru/search";

/* ================= HELPERS ================= */
const qs = k => new URLSearchParams(location.search).get(k);
const spinner = document.getElementById("spinner");
const subtitleEl = document.getElementById("subtitleText");

function showSpinner(v){
    spinner.style.display = v ? "flex" : "none";
}

function toSec(t){
    const p=t.replace(",",".").split(":");
    return (+p[0])*3600+(+p[1])*60+parseFloat(p[2]);
}

function parseVTT(vtt){
    return vtt.split("\n\n").map(b=>{
        if(!b.includes("-->")) return null;
        const l=b.split("\n");
        const [s,e]=l[0].split(" --> ");
        return {start:toSec(s),end:toSec(e),text:l.slice(1).join("\n")};
    }).filter(Boolean);
}

/* ================= SLUG ================= */
const TITLE = qs("title") || qs("tittle");
const IMDB = qs("id");
const SEASON = qs("season");
const EPISODE = qs("episode");

if(!TITLE){
    alert("Missing ?title=");
    throw new Error("No title");
}

/* ================= FETCH STREAM ================= */
async function getStream(){
    showSpinner(true);
    const r = await fetch(PROXY + encodeURIComponent(`${STREAM_API}?title=${TITLE}`));
    const j = await r.json();
    return PROXY + encodeURIComponent(j.m3u8_url);
}

/* ================= FETCH SUBS ================= */
async function getSubs(){
    if(!IMDB) return [];
    let u = `${SUB_API}?id=${IMDB}`;
    if(SEASON && EPISODE) u+=`&season=${SEASON}&episode=${EPISODE}`;
    return await (await fetch(PROXY + encodeURIComponent(u))).json();
}

/* ================= INIT ================= */
(async()=>{
const streamUrl = await getStream();
const subs = await getSubs();

let cues=[];
let activeHls=null;

const art = new Artplayer({
    container:"#player",
    url:streamUrl,
    type:"m3u8",
    autoplay:true,
    setting:true,
    hotkey:true,
    pip:true,
    fullscreen:true,
    playbackRate:true,
    aspectRatio:true,
    screenshot:true,
    lock:true,
    mutex:true,
    theme:"#e50914",

    customType:{
        m3u8(video,url){
            if(activeHls) activeHls.destroy();

            const hls=new Hls({
                maxBufferLength:30,
                maxMaxBufferLength:60
            });
            activeHls=hls;
            hls.loadSource(url);
            hls.attachMedia(video);

            /* QUALITY */
            hls.on(Hls.Events.MANIFEST_PARSED,()=>{
                showSpinner(false);
                art.setting.add({
                    name:"quality",
                    html:"Quality",
                    selector:[
                        {html:"Auto",level:-1,default:true},
                        ...hls.levels.map((l,i)=>({html:l.height+"p",level:i}))
                    ],
                    onSelect:i=>{
                        hls.currentLevel=i.level;
                        return i.html;
                    }
                });
            });

            /* AUDIO */
            hls.on(Hls.Events.AUDIO_TRACKS_UPDATED,(_,d)=>{
                if(d.audioTracks.length>1){
                    art.setting.add({
                        name:"audio",
                        html:"Audio",
                        selector:d.audioTracks.map((t,i)=>({
                            html:t.name||t.lang||"Track "+(i+1),
                            index:i,
                            default:i===hls.audioTrack
                        })),
                        onSelect:i=>{
                            hls.audioTrack=i.index;
                            return i.html;
                        }
                    });
                }
            });
        }
    }
});

/* SPINNER EVENTS */
art.on("video:loadstart",()=>showSpinner(true));
art.on("video:waiting",()=>showSpinner(true));
art.on("video:stalled",()=>showSpinner(true));
art.on("video:playing",()=>showSpinner(false));

/* SUBTITLES */
if(subs.length){
    art.setting.add({
        name:"subtitle",
        html:"Subtitles",
        selector:subs.map((s,i)=>({
            html:s.language || s.lang || "Subtitle "+(i+1),
            url:PROXY + encodeURIComponent(s.url),
            default:i===0
        })),
        onSelect:async i=>{
            const t=await (await fetch(i.url)).text();
            cues=parseVTT(t);
            subtitleEl.textContent="";
            return i.html;
        }
    });

    const t=await (await fetch(PROXY + encodeURIComponent(subs[0].url))).text();
    cues=parseVTT(t);
}

/* SUBTITLE RENDER LOOP */
art.on("video:timeupdate",()=>{
    const t=art.currentTime;
    const c=cues.find(x=>t>=x.start && t<=x.end);
    subtitleEl.textContent = c ? c.text : "";
});
})();
</script>

</body>
</html>
