<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Netflix Player</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link rel="stylesheet" href="https://unpkg.com/artplayer@5.3.0/dist/artplayer.css">

<style>
html,body{
    margin:0;
    padding:0;
    background:#000;
}

/* PLAYER */
#player{
    width:100%;
    max-width:500px;
    height:400px;
    margin:40px auto;
    position:relative;
    background:#000;
}

/* NETFLIX SPINNER */
.loading-spinner-container{
    display:flex;
    align-items:center;
    justify-content:center;
    width:64px;
    height:64px;
}
.loading-spinner-container img{
    width:64px;
    height:64px;
    animation:spin 1.1s linear infinite;
}
@keyframes spin{
    from{transform:rotate(0deg)}
    to{transform:rotate(360deg)}
}

/* ===== SUBTITLE STYLE ===== */
.custom-subtitle-container {
    position: absolute;
    bottom: 50px;
    left: 0;
    right: 0;
    display: flex;
    justify-content: center;
    pointer-events: none;
    z-index: 100;
}

.custom-subtitle-text {
    padding: 5px 15px;
    font-size: 20px;
    font-weight: 500;
    color: #fff;
    background: rgba(0, 0, 0, 0.5);
    text-shadow: 0 2px 4px rgba(0,0,0,0.9);
    border-radius: 4px;
    text-align: center;
    white-space: pre-wrap;
    max-width: 85%;
}
</style>
</head>

<body>

<div id="player"></div>

<script src="https://unpkg.com/hls.js@1.5.17/dist/hls.min.js"></script>
<script src="https://unpkg.com/artplayer@5.3.0/dist/artplayer.js"></script>

<script>
/* ===============================
   URL PARAMS
================================ */
const q = new URLSearchParams(location.search);
const TITLE   = q.get('title');
const IMDB_ID = q.get('id');
const SEASON  = q.get('season');
const EPISODE = q.get('episode');

if(!TITLE){
    alert("Missing title param");
    throw new Error("No title");
}

/* ===============================
   PROXY
================================ */
const proxy = u => 'https://workingg.vercel.app/api/proxy?url=' + encodeURIComponent(u);

/* ===============================
   FETCH STREAM
================================ */
async function getStream(){
    const r = await fetch(proxy(`https://u-1-1azw.onrender.com/api/get-stream?title=${TITLE}`));
    const j = await r.json();
    if(!j.m3u8_url) throw "No stream";
    return proxy(j.m3u8_url);
}

/* ===============================
   FETCH SUBTITLES
================================ */
async function getSubtitles(){
    if(!IMDB_ID) return [];
    let u = `https://sub.wyzie.ru/search?id=${IMDB_ID}`;
    if(SEASON && EPISODE) u += `&season=${SEASON}&episode=${EPISODE}`;
    const r = await fetch(proxy(u));
    return await r.json();
}

/* ===============================
   PARSE VTT / SRT
================================ */
function parseSub(text){
    const cues=[];
    const cleanText = text.replace(/^WEBVTT\s+/i, '').trim();
    const blocks=cleanText.replace(/\r/g,'').split('\n\n');
    
    for(const b of blocks){
        const lines=b.split('\n');
        if(lines.length < 2) continue;

        const timeLineIndex = lines.findIndex(l => l.includes('-->'));
        if(timeLineIndex === -1) continue;

        const timeLine = lines[timeLineIndex];
        const content = lines.slice(timeLineIndex + 1).join('\n');

        try {
            const [s,e] = timeLine.split('-->').map(t=>{
                const p = t.trim().replace(',','.');
                const parts = p.split(':');
                let h=0, m=0, s_ms=0;
                
                if(parts.length === 3) [h, m, s_ms] = parts;
                else [m, s_ms] = parts;
                
                const [sec, ms] = s_ms.split('.');
                return (+h)*3600 + (+m)*60 + (+sec) + (+ms||0)/1000;
            });
            cues.push({s, e, t: content});
        } catch(e) {}
    }
    return cues;
}

/* ===============================
   INIT PLAYER
================================ */
(async()=>{
const m3u8=await getStream();
const subs=await getSubtitles();

let subtitleCues=[];
let activeSub=null;
let subOffset = 0; // Manual sync adjustment

const art=new Artplayer({
    container:'#player',
    url:m3u8,
    type:'m3u8',
    autoplay:true,
    setting:true,
    fullscreen:true,
    fullscreenWeb:true,
    pip:true,
    playbackRate:true,
    aspectRatio:true,
    screenshot:true,
    miniProgressBar:true,
    mutex:true,
    backdrop:true,
    playsInline:true,
    theme:'#e50914',
    // RESUME FEATURE
    autoPlayback: true,
    resume: true, 
    storage: true,
    layers: [
        {
            name: 'subtitle-layer',
            html: '<div class="custom-subtitle-container"><div id="sub-text" class="custom-subtitle-text"></div></div>',
            style: { display: 'none' },
        },
    ],
    icons:{
        loading:`<div class="loading-spinner-container"><img src="https://assets.nflxext.com/en_us/pages/wiplayer/site-spinner.png"></div>`
    },
    customType:{
        m3u8(video,url){
            if(Hls.isSupported()){
                const hls=new Hls();
                hls.loadSource(url);
                hls.attachMedia(video);
                art.hls=hls;

                hls.on(Hls.Events.MANIFEST_PARSED,()=>{
                    art.setting.add({
                        name:'quality',
                        html:'Quality',
                        selector:[
                            {html:'Auto',level:-1,default:true},
                            ...hls.levels.map((l,i)=>({html:l.height+'p',level:i}))
                        ],
                        onSelect:i=>{
                            hls.currentLevel=i.level;
                            return i.html;
                        }
                    });
                });

                // RESTORED AUDIO SETTINGS
                hls.on(Hls.Events.AUDIO_TRACKS_UPDATED, (_, d) => {
                    if (d.audioTracks.length > 1) {
                        art.setting.add({
                            name: 'audio',
                            html: 'Audio',
                            selector: d.audioTracks.map((t, i) => ({
                                html: t.name || t.lang || `Track ${i}`,
                                index: i,
                                default: i === hls.audioTrack
                            })),
                            onSelect: s => {
                                hls.audioTrack = s.index;
                                return s.html;
                            }
                        });
                    }
                });
            }
        }
    }
});

const subLayer = art.layers['subtitle-layer'];
const subText = document.getElementById('sub-text');

/* ===== SUBTITLE MENU ===== */
if(subs.length){
    art.setting.add({
        name:'subtitle',
        html:'Subtitles',
        selector:[
            {html:'Off',url:null,default:true},
            ...subs.map(s=>({
                html:s.lang||s.language||'Subtitle',
                url:proxy(s.url)
            }))
        ],
        onSelect:async i=>{
            if(!i.url){
                subLayer.style.display='none';
                subtitleCues=[];
                return 'Off';
            }
            const t=await fetch(i.url).then(r=>r.text());
            subtitleCues=parseSub(t);
            subLayer.style.display='flex';
            return i.html;
        }
    });

    // ADD SUBTITLE DELAY SETTING
    art.setting.add({
        name: 'sub-delay',
        html: 'Subtitle Delay',
        selector: [
            {html: '-5s', value: -5},
            {html: '-2s', value: -2},
            {html: '-1s', value: -1},
            {html: 'Original', value: 0, default: true},
            {html: '+1s', value: 1},
            {html: '+2s', value: 2},
            {html: '+5s', value: 5},
        ],
        onSelect: i => {
            subOffset = i.value;
            return i.html;
        }
    });
}

/* ===== SYNC SUBTITLES (Fixed Sync Logic) ===== */
art.on('video:timeupdate', () => {
    if(!subtitleCues.length) return;
    
    // Apply offset to current video time to find the cue
    const t = art.currentTime + subOffset;
    const cue = subtitleCues.find(c => t >= c.s && t <= c.e);

    if(cue) {
        if(cue !== activeSub) {
            subText.innerHTML = cue.t.replace(/\n/g, '<br>');
            activeSub = cue;
        }
    } else {
        subText.innerHTML = '';
        activeSub = null;
    }
});

/* ===== RESUME PLAYBACK NOTIFICATION ===== */
art.on('ready', () => {
    const lastTime = art.storage.get(art.options.url);
    if (lastTime > 10) {
        console.log(`Resuming from ${lastTime}s`);
    }
});

// UI: Move subs up when controls appear
art.on('control', (state) => {
    subLayer.style.bottom = state ? '90px' : '40px';
});

})();
</script>
</body>
</html>
