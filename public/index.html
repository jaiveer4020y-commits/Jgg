<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Netflix Player</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link rel="stylesheet" href="https://unpkg.com/artplayer@5.3.0/dist/artplayer.css">

<style>
html,body{
    margin:0;
    padding:0;
    background:#000;
}

/* PLAYER */
#player{
    width:100%;
    max-width:980px;
    height:560px;
    margin:40px auto;
    position:relative;
    background:#000;
}

/* NETFLIX SPINNER */
.loading-spinner-container{
    display:flex;
    align-items:center;
    justify-content:center;
    width:64px;
    height:64px;
}
.loading-spinner-container img{
    width:64px;
    height:64px;
    animation:spin 1.1s linear infinite;
}
@keyframes spin{
    from{transform:rotate(0deg)}
    to{transform:rotate(360deg)}
}

/* STYLING THE NATIVE SUBTITLE DIV */
.art-subtitle {
    font-size: 26px !important;
    text-shadow: 0 2px 4px rgba(0,0,0,0.9);
    background: rgba(0, 0, 0, 0.4) !important;
    padding: 5px 15px !important;
    border-radius: 5px;
    bottom: 10% !important;
}
</style>
</head>

<body>

<div id="player"></div>

<script src="https://unpkg.com/hls.js@1.5.17/dist/hls.min.js"></script>
<script src="https://unpkg.com/artplayer@5.3.0/dist/artplayer.js"></script>

<script>
/* ===============================
   URL PARAMS
================================ */
const q = new URLSearchParams(location.search);
const TITLE   = q.get('title');
const IMDB_ID = q.get('id');
const SEASON  = q.get('season');
const EPISODE = q.get('episode');

if(!TITLE){
    alert("Missing title param");
    throw new Error("No title");
}

/* ===============================
   PROXY
================================ */
const proxy = u => 'https://workingg.vercel.app/api/proxy?url=' + encodeURIComponent(u);

/* ===============================
   FETCH STREAM
================================ */
async function getStream(){
    const r = await fetch(proxy(`https://u-1-1azw.onrender.com/api/get-stream?title=${TITLE}`));
    const j = await r.json();
    if(!j.m3u8_url) throw "No stream";
    return proxy(j.m3u8_url);
}

/* ===============================
   FETCH SUBTITLES
================================ */
async function getSubtitles(){
    if(!IMDB_ID) return [];
    let u = `https://sub.wyzie.ru/search?id=${IMDB_ID}`;
    if(SEASON && EPISODE) u += `&season=${SEASON}&episode=${EPISODE}`;
    const r = await fetch(proxy(u));
    return await r.json();
}

/* ===============================
   INIT PLAYER
================================ */
(async()=>{
const m3u8=await getStream();
const subs=await getSubtitles();

const art=new Artplayer({
    container:'#player',
    url:m3u8,
    type:'m3u8',
    autoplay:true,
    setting:true,
    fullscreen:true,
    fullscreenWeb:true,
    pip:true,
    playbackRate:true,
    aspectRatio:true,
    screenshot:true,
    miniProgressBar:true,
    mutex:true,
    backdrop:true,
    playsInline:true,
    resume:true,
    lock:true,
    fastForward:true,
    theme:'#e50914',
    // NATIVE SUBTITLE CONFIG
    subtitle: {
        url: '',
        style: {
            color: '#fff',
            fontSize: '24px',
        },
    },
    icons:{
        loading:`
        <div class="loading-spinner-container">
            <img src="https://assets.nflxext.com/en_us/pages/wiplayer/site-spinner.png">
        </div>`
    },
    customType:{
        m3u8(video,url){
            if(Hls.isSupported()){
                const hls=new Hls();
                hls.loadSource(url);
                hls.attachMedia(video);
                art.hls=hls;

                hls.on(Hls.Events.MANIFEST_PARSED,()=>{
                    art.setting.add({
                        name:'quality',
                        html:'Quality',
                        selector:[
                            {html:'Auto',level:-1,default:true},
                            ...hls.levels.map((l,i)=>({html:l.height+'p',level:i}))
                        ],
                        onSelect:i=>{
                            hls.currentLevel=i.level;
                            return i.html;
                        }
                    });
                });

                hls.on(Hls.Events.AUDIO_TRACKS_UPDATED,(_,d)=>{
                    if(d.audioTracks.length>1){
                        art.setting.add({
                            name:'audio',
                            html:'Audio',
                            selector:d.audioTracks.map((t,i)=>({
                                html:t.name||t.lang||`Track ${i}`,
                                index:i,
                                default:i===hls.audioTrack
                            })),
                            onSelect:s=>{
                                hls.audioTrack=s.index;
                                return s.html;
                            }
                        });
                    }
                });
            }
        }
    }
});

/* ===== NATIVE SUBTITLE MENU ===== */
if(subs.length){
    art.setting.add({
        name:'subtitle',
        html:'Subtitles',
        selector:[
            {html:'Off',url:null,default:true},
            ...subs.map(s=>({
                html:s.lang||s.language||'Subtitle',
                url:proxy(s.url)
            }))
        ],
        onSelect: i => {
            if(!i.url){
                art.subtitle.show = false;
                return 'Off';
            }
            // Use Artplayer's native subtitle loader
            art.subtitle.url = i.url;
            art.subtitle.show = true;
            return i.html;
        }
    });
}

})();
</script>
</body>
</html>
