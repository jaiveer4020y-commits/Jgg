<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Netflix ArtPlayer</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link rel="stylesheet" href="https://unpkg.com/artplayer@5.3.0/dist/artplayer.css">
<script src="https://unpkg.com/artplayer@5.3.0/dist/artplayer.js"></script>
<script src="https://unpkg.com/hls.js@1.5.17/dist/hls.min.js"></script>

<style>
html,body{
    margin:0;
    padding:0;
    width:100%;
    height:100%;
    background:#000;
    overflow:hidden;
}

/* PLAYER */
#player{
    position:relative;
    width:100%;
    height:100%;
    background:#000;
}

/* ================= NETFLIX SPINNER ================= */
.loading-spinner-container{
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    background:#000;
    z-index:999999;
}
.loading-spinner-container img{
    width:64px;
    height:64px;
}

/* ================= SUBTITLE OVERLAY ================= */
#subtitle-overlay{
    position:absolute;
    left:50%;
    bottom:10%;
    transform:translateX(-50%);
    width:90%;
    text-align:center;
    pointer-events:none;
    z-index:999998;
}

#subtitle-overlay span{
    display:inline-block;
    padding:6px 10px;
    font-size:23px;
    font-weight:500;
    color:#fcf4f4;
    background:rgba(0,0,0,0);
    text-shadow:
        0 2px 4px rgba(0,0,0,0.9),
        0 0 2px rgba(0,0,0,0.9);
    white-space:pre-wrap;
    line-height:1.4;
}
</style>
</head>

<body>

<div id="player"></div>

<!-- SUBTITLE -->
<div id="subtitle-overlay"><span></span></div>

<!-- NETFLIX SPINNER -->
<div class="loading-spinner-container" id="spinner">
    <img src="https://assets.nflxext.com/en_us/pages/wiplayer/site-spinner.png"
         onerror="this.src='https://placehold.co/64x64/cccccc/333333?text=Loading'">
</div>

<script>
/* ================= CONSTANTS ================= */
const RENDER_API = "https://u-1-1azw.onrender.com/api/get-stream";
const SUB_API = "https://sub.wyzie.ru/search";
const PROXY = "https://workingg.vercel.app/api/proxy?url=";

/* ================= HELPERS ================= */
const qs = k => new URLSearchParams(location.search).get(k);
const spinner = document.getElementById("spinner");
const subtitleText = document.querySelector("#subtitle-overlay span");

function showSpinner(v){
    spinner.style.display = v ? "flex" : "none";
}

function toSeconds(t){
    const p = t.replace(",",".").split(":");
    return (+p[0])*3600 + (+p[1])*60 + parseFloat(p[2]);
}

function parseVTT(vtt){
    const cues=[];
    vtt.split("\n\n").forEach(block=>{
        if(!block.includes("-->")) return;
        const lines = block.split("\n");
        const [start,end] = lines[0].split(" --> ");
        cues.push({
            start:toSeconds(start),
            end:toSeconds(end),
            text:lines.slice(1).join("\n")
        });
    });
    return cues;
}

/* ================= SLUG ================= */
const TITLE = qs("title") || qs("tittle");
const IMDB = qs("id");
const SEASON = qs("season");
const EPISODE = qs("episode");

if(!TITLE){
    alert("Missing ?title=");
    throw new Error("No title");
}

/* ================= FETCH STREAM ================= */
async function getStream(){
    showSpinner(true);
    const api = `${RENDER_API}?title=${encodeURIComponent(TITLE)}`;
    const r = await fetch(PROXY + encodeURIComponent(api));
    const j = await r.json();
    return PROXY + encodeURIComponent(j.m3u8_url);
}

/* ================= FETCH SUBS ================= */
async function getSubs(){
    if(!IMDB) return [];
    let url = `${SUB_API}?id=${IMDB}`;
    if(SEASON && EPISODE) url += `&season=${SEASON}&episode=${EPISODE}`;
    const r = await fetch(PROXY + encodeURIComponent(url));
    const j = await r.json();

    return j.map(s=>({
        name: s.language || s.lang || s.label || s.name || "Subtitle",
        url: PROXY + encodeURIComponent(s.url)
    }));
}

/* ================= MAIN ================= */
(async()=>{
const streamUrl = await getStream();
const subtitles = await getSubs();

let cues = [];
let activeCue = null;

const art = new Artplayer({
    container:"#player",
    url:streamUrl,
    type:"m3u8",
    autoplay:true,
    setting:true,
    hotkey:true,
    pip:true,
    fullscreen:true,
    playbackRate:true,
    aspectRatio:true,
    screenshot:true,
    lock:true,
    mutex:true,
    autoPlayback:true,
    theme:"#e50914",
    icons:{ loading:"" },

    customType:{
        m3u8(video,url){
            const hls = new Hls({
                maxBufferLength:30,
                enableWorker:true
            });

            hls.loadSource(url);
            hls.attachMedia(video);

            hls.on(Hls.Events.MANIFEST_PARSED,()=>{
                showSpinner(false);

                art.setting.add({
                    name:"quality",
                    html:"Quality",
                    selector:[
                        {html:"Auto",level:-1,default:true},
                        ...hls.levels.map((l,i)=>({html:l.height+"p",level:i}))
                    ],
                    onSelect:i=>{
                        hls.currentLevel=i.level;
                        return i.html;
                    }
                });
            });

            hls.on(Hls.Events.AUDIO_TRACKS_UPDATED,(_,d)=>{
                if(d.audioTracks.length>1){
                    art.setting.add({
                        name:"audio",
                        html:"Audio",
                        selector:d.audioTracks.map((t,i)=>({
                            html:t.name||t.lang||`Track ${i}`,
                            index:i,
                            default:i===hls.audioTrack
                        })),
                        onSelect:i=>{
                            hls.audioTrack=i.index;
                            return i.html;
                        }
                    });
                }
            });

            hls.on(Hls.Events.ERROR,()=>{
                showSpinner(true);
            });
        }
    }
});

/* ===== SUBTITLE SETTING ===== */
if(subtitles.length){
    art.setting.add({
        name:"subtitle",
        html:"Subtitles",
        selector:subtitles.map((s,i)=>({
            html:s.name,
            url:s.url,
            default:i===0
        })),
        onSelect:async item=>{
            const r = await fetch(item.url);
            cues = parseVTT(await r.text());
            subtitleText.textContent="";
            return item.html;
        }
    });

    const r = await fetch(subtitles[0].url);
    cues = parseVTT(await r.text());
}

/* ===== SUBTITLE SYNC ===== */
art.on("video:timeupdate",()=>{
    const t = art.currentTime;
    const cue = cues.find(c=>t>=c.start && t<=c.end);
    if(cue && cue!==activeCue){
        subtitleText.textContent = cue.text;
        activeCue = cue;
    }else if(!cue){
        subtitleText.textContent = "";
        activeCue = null;
    }
});

/* ===== SPINNER EVENTS ===== */
art.on("waiting",()=>showSpinner(true));
art.on("playing",()=>showSpinner(false));
})();
</script>
</body>
</html>
