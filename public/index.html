<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>NETFLIX PRO ENGINE | Ultimate Build</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#000000">

    <link rel="stylesheet" href="https://unpkg.com/artplayer@5.3.0/dist/artplayer.css">
    <script src="https://unpkg.com/hls.js@1.5.17/dist/hls.min.js"></script>
    <script src="https://unpkg.com/artplayer@5.3.0/dist/artplayer.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;800;900&display=swap" rel="stylesheet">

    <style>
        /* --- CORE VARIABLES --- */
        :root {
            --netflix-red: #E50914;
            --netflix-dark: #141414;
            --netflix-black: #000000;
            --text-white: #FFFFFF;
            --text-gray: #B3B3B3;
            --glass-panel: rgba(20, 20, 20, 0.95);
        }

        /* --- GLOBAL RESET --- */
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body, html {
            margin: 0; padding: 0; width: 100vw; height: 100vh;
            background-color: var(--netflix-black); color: var(--text-white);
            font-family: 'Montserrat', sans-serif; overflow: hidden;
        }

        /* --- 1. DASHBOARD UI (Search & Input) --- */
        #dashboard-layer {
            position: fixed; inset: 0; z-index: 10;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: radial-gradient(circle at center, #1f1f1f 0%, #000000 100%);
            transition: opacity 0.5s ease;
        }

        .brand-header {
            font-size: 3.5rem; font-weight: 900; color: var(--netflix-red);
            letter-spacing: -2px; margin-bottom: 40px; text-transform: uppercase;
            text-shadow: 0 0 30px rgba(229, 9, 20, 0.4);
        }

        .control-box {
            width: 90%; max-width: 500px; padding: 30px;
            background: #181818; border: 1px solid #333; border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.6); position: relative;
        }

        .input-wrapper { position: relative; margin-bottom: 20px; }
        .input-label {
            font-size: 11px; color: var(--text-gray); text-transform: uppercase;
            letter-spacing: 1.5px; margin-bottom: 8px; display: block; font-weight: 700;
        }

        input[type="text"], input[type="number"] {
            width: 100%; padding: 16px; background: #000; border: 1px solid #333;
            border-radius: 6px; color: #fff; font-size: 16px; outline: none;
            transition: border-color 0.2s;
        }
        input:focus { border-color: var(--netflix-red); }

        /* Dynamic Search Dropdown */
        #search-results-dropdown {
            position: absolute; top: 100%; left: 0; right: 0;
            background: #161616; border: 1px solid #333; border-top: none;
            border-radius: 0 0 6px 6px; z-index: 100; max-height: 350px;
            overflow-y: auto; display: none;
        }
        .search-result-item {
            display: flex; align-items: center; padding: 12px; cursor: pointer;
            border-bottom: 1px solid #222; transition: background 0.2s;
        }
        .search-result-item:hover { background: #252525; }
        .search-result-item img {
            width: 40px; height: 60px; object-fit: cover; border-radius: 4px; margin-right: 15px;
        }
        .search-info h4 { margin: 0; font-size: 14px; color: #fff; }
        .search-info span { font-size: 11px; color: #888; text-transform: uppercase; }

        .btn-action {
            width: 100%; padding: 18px; background: var(--netflix-red);
            color: #fff; font-weight: 800; font-size: 16px; border: none;
            border-radius: 6px; cursor: pointer; text-transform: uppercase;
            letter-spacing: 1px; transition: transform 0.1s;
        }
        .btn-action:active { transform: scale(0.98); }

        /* --- 2. LOADING LAYER (With NETFLIX SPINNER) --- */
        #loading-overlay {
            position: fixed; inset: 0; background: #000; z-index: 9999;
            display: none; flex-direction: column; align-items: center; justify-content: center;
        }

        #backdrop-image {
            position: absolute; inset: 0; width: 100%; height: 100%;
            object-fit: cover; opacity: 0.3; filter: brightness(0.5);
            transition: opacity 1s;
        }

        .loader-content {
            position: relative; z-index: 10; display: flex; flex-direction: column; align-items: center;
        }

        #title-logo {
            max-width: 280px; margin-bottom: 40px; filter: drop-shadow(0 10px 20px rgba(0,0,0,0.8));
        }

        /* NETFLIX SPINNER CONTAINER */
        .nf-spinner-container {
            width: 70px; height: 70px;
            animation: nf-rotate 1.1s linear infinite;
        }
        .nf-spinner-container img { width: 100%; height: 100%; display: block; }
        @keyframes nf-rotate { 100% { transform: rotate(360deg); } }

        .loading-status {
            margin-top: 25px; color: var(--netflix-red); font-size: 12px; 
            font-weight: 700; letter-spacing: 3px; text-transform: uppercase;
        }

        /* --- 3. PLAYER CONTAINER (Centered) --- */
        #player-wrapper {
            position: fixed; inset: 0; background: #000; z-index: 10000;
            display: none; align-items: center; justify-content: center;
        }

        #artplayer {
            width: 100%; height: 100%; position: relative;
        }

        /* --- 4. PLAYER OVERLAYS --- */
        
        /* Custom Close Button */
        .btn-close-player {
            position: absolute; top: 30px; right: 30px; width: 50px; height: 50px;
            background: rgba(0,0,0,0.5); border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            color: #fff; cursor: pointer; z-index: 999; transition: 0.2s; font-size: 24px;
        }
        .btn-close-player:hover { background: var(--netflix-red); border-color: var(--netflix-red); }

        /* Custom Center Controls (Play/Pause/Seek) */
        .art-layer-center-ui {
            width: 100%; height: 100%; display: flex; align-items: center; 
            justify-content: center; gap: 60px; pointer-events: none;
            opacity: 0; transition: opacity 0.3s;
        }
        .art-state-show .art-layer-center-ui { opacity: 1; }
        
        .control-icon {
            width: 80px; height: 80px; background: rgba(0,0,0,0.6);
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            pointer-events: auto; cursor: pointer; backdrop-filter: blur(4px);
            border: 1px solid rgba(255,255,255,0.1); transition: 0.2s;
        }
        .control-icon:hover { transform: scale(1.1); background: rgba(229, 9, 20, 0.8); }
        .control-icon svg { width: 36px; height: 36px; fill: #fff; }

        /* Custom Subtitle Render Box */
        .art-layer-subtitle-renderer {
            position: absolute; bottom: 12%; left: 0; width: 100%;
            display: flex; justify-content: center; pointer-events: none; z-index: 20;
        }
        #custom-subtitle-text {
            background: rgba(0,0,0,0.7); padding: 6px 20px; border-radius: 4px;
            color: #fff; font-size: clamp(18px, 4vw, 32px); text-align: center;
            text-shadow: 2px 2px 2px #000; display: none; max-width: 90%;
            font-weight: 600; line-height: 1.4;
        }

        /* --- OVERRIDE DEFAULT ARTPLAYER SPINNER --- */
        .art-loading .art-loading-icon { display: none !important; }
        .art-loading .nf-spinner-container { display: block !important; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
    </style>
</head>
<body>

<div id="dashboard-layer">
    <div class="brand-header">NETFLIX PRO</div>
    
    <div class="control-box">
        <div class="input-wrapper">
            <label class="input-label">Universal Search</label>
            <input type="text" id="search-input" placeholder="Search Movies or TV Shows..." autocomplete="off">
            <div id="search-results-dropdown"></div>
        </div>

        <div class="input-wrapper">
            <label class="input-label">TMDB Identity</label>
            <input type="text" id="tmdb-id-input" placeholder="Waiting for selection..." readonly>
        </div>

        <div id="series-controls" style="display: none; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
            <div class="input-wrapper" style="margin:0;">
                <label class="input-label">Season</label>
                <input type="number" id="season-input" value="1" min="1">
            </div>
            <div class="input-wrapper" style="margin:0;">
                <label class="input-label">Episode</label>
                <input type="number" id="episode-input" value="1" min="1">
            </div>
        </div>

        <button class="btn-action" onclick="initiatePlayback()">Play Content</button>
        
        <div style="margin-top: 20px; text-align: center; font-family: monospace; font-size: 10px; color: #555;">
            ROUTER PATH: <span id="current-path" style="color: var(--netflix-red);">/</span>
        </div>
    </div>
</div>

<div id="loading-overlay">
    <img id="backdrop-image" src="">
    <div class="loader-content">
        <img id="title-logo" src="">
        <div class="nf-spinner-container">
            <img src="https://assets.nflxext.com/en_us/pages/wiplayer/site-spinner.png" alt="Loading">
        </div>
        <div class="loading-status" id="loading-text">CONNECTING TO SERVER</div>
    </div>
</div>

<div id="player-wrapper">
    <div class="btn-close-player" onclick="destroyPlayer()">✕</div>
    <div id="artplayer"></div>
</div>

<script>
/**
 * ============================================================================
 * CONFIGURATION & UTILITIES
 * ============================================================================
 */
const CONFIG = {
    TMDB_KEY: '463dcd7993ab31d92eb586802fdeee6a',
    PROXY: (url) => `https://workingg.vercel.app/api/proxy?url=${encodeURIComponent(url)}`,
    SPINNER_IMG: 'https://assets.nflxext.com/en_us/pages/wiplayer/site-spinner.png'
};

let playerInstance = null;
let currentMetadata = null;
let subtitleCueList = [];
let activeSubtitleCue = null;

/**
 * ============================================================================
 * 1. ROUTING ENGINE (Clean URL Handler)
 * ============================================================================
 */
window.addEventListener('load', async () => {
    // Parse URL: /id/season/episode or /id
    const pathSegments = window.location.pathname.split('/').filter(Boolean);
    
    // Update Debug Text
    document.getElementById('current-path').innerText = window.location.pathname;

    if (pathSegments.length >= 1 && !isNaN(pathSegments[0])) {
        // We have a deep link!
        const id = pathSegments[0];
        const season = pathSegments[1] || 1;
        const episode = pathSegments[2] || 1;
        
        // Is it likely a movie or TV? If 3 params, definitely TV.
        // We'll fetch TV meta first, if fails, try movie.
        console.log(`[ROUTER] Detected ID: ${id}, S:${season}, E:${episode}`);
        
        // Fill UI hidden fields
        document.getElementById('tmdb-id-input').value = id;
        document.getElementById('season-input').value = season;
        document.getElementById('episode-input').value = episode;
        
        // Auto Start
        await autoResolveAndPlay(id, season, episode);
    }
});

async function autoResolveAndPlay(id, s, e) {
    // Show Loader immediately
    document.getElementById('loading-overlay').style.display = 'flex';
    document.getElementById('loading-text').innerText = "RESOLVING METADATA...";
    
    // Try Fetching as TV Show First
    let type = 'tv';
    let meta = await fetch(`https://api.themoviedb.org/3/tv/${id}?api_key=${CONFIG.TMDB_KEY}`).then(r => r.json());
    
    // If error, try Movie
    if (meta.success === false || meta.status_code === 34) {
        type = 'movie';
        meta = await fetch(`https://api.themoviedb.org/3/movie/${id}?api_key=${CONFIG.TMDB_KEY}`).then(r => r.json());
    }

    if (meta.id) {
        currentMetadata = meta;
        document.getElementById('series-controls').style.display = (type === 'tv') ? 'grid' : 'none';
        
        // Trigger Playback Logic
        performHandshake(type, id, s, e, meta);
    } else {
        alert("Invalid ID in URL");
        document.getElementById('loading-overlay').style.display = 'none';
    }
}

/**
 * ============================================================================
 * 2. DYNAMIC SEARCH UI
 * ============================================================================
 */
const searchInput = document.getElementById('search-input');
const resultsDrop = document.getElementById('search-results-dropdown');

searchInput.addEventListener('input', async (e) => {
    const query = e.target.value;
    if (query.length < 2) { resultsDrop.style.display = 'none'; return; }

    try {
        const res = await fetch(`https://api.themoviedb.org/3/search/multi?api_key=${CONFIG.TMDB_KEY}&query=${encodeURIComponent(query)}`);
        const data = await res.json();
        
        resultsDrop.innerHTML = '';
        if (data.results && data.results.length > 0) {
            resultsDrop.style.display = 'block';
            data.results.slice(0, 6).forEach(item => {
                if (!item.poster_path) return;
                
                const el = document.createElement('div');
                el.className = 'search-result-item';
                el.innerHTML = `
                    <img src="https://image.tmdb.org/t/p/w92${item.poster_path}">
                    <div class="search-info">
                        <h4>${item.title || item.name}</h4>
                        <span>${(item.release_date||item.first_air_date||'').split('-')[0]} • ${item.media_type.toUpperCase()}</span>
                    </div>
                `;
                el.onclick = () => selectSearchResult(item);
                resultsDrop.appendChild(el);
            });
        }
    } catch (err) { console.error(err); }
});

function selectSearchResult(item) {
    currentMetadata = item;
    searchInput.value = item.title || item.name;
    document.getElementById('tmdb-id-input').value = item.id;
    
    const isSeries = (item.media_type === 'tv' || item.name !== undefined);
    document.getElementById('series-controls').style.display = isSeries ? 'grid' : 'none';
    
    resultsDrop.style.display = 'none';
}

/**
 * ============================================================================
 * 3. STREAMING LOGIC & SLUG GENERATION (The Core Fix)
 * ============================================================================
 */
async function initiatePlayback() {
    const id = document.getElementById('tmdb-id-input').value;
    if (!id) return alert("Please search and select a title first.");
    
    const s = document.getElementById('season-input').value;
    const e = document.getElementById('episode-input').value;
    const isSeries = document.getElementById('series-controls').style.display === 'grid';
    
    // If metadata isn't fully loaded (manual ID entry), fetch it now
    if (!currentMetadata || currentMetadata.id != id) {
        await autoResolveAndPlay(id, s, e); 
        return; // autoResolve calls performHandshake
    }

    performHandshake(isSeries ? 'tv' : 'movie', id, s, e, currentMetadata);
}

async function performHandshake(type, id, s, e, meta) {
    const loader = document.getElementById('loading-overlay');
    loader.style.display = 'flex';
    
    // Set UI Visuals
    const backdrop = meta.backdrop_path ? `https://image.tmdb.org/t/p/original${meta.backdrop_path}` : '';
    document.getElementById('backdrop-image').src = backdrop;
    
    // Fetch Logo
    const imgData = await fetch(`https://api.themoviedb.org/3/${type}/${id}/images?api_key=${CONFIG.TMDB_KEY}`).then(r=>r.json());
    const logoPath = imgData.logos?.find(l => l.iso_639_1 === 'en')?.file_path || imgData.logos?.[0]?.file_path;
    document.getElementById('title-logo').src = logoPath ? `https://image.tmdb.org/t/p/w500${logoPath}` : '';

    // --- SLUG GENERATION STRATEGY ---
    // This is the most critical part to fix "No video found"
    const rawTitle = (meta.title || meta.name || '').toLowerCase();
    const cleanTitle = rawTitle.replace(/[^a-z0-9\s]/gi, '').trim().replace(/\s+/g, '.');
    
    // We will try these slugs in order
    let possibleSlugs = [];
    if (type === 'movie') {
        const year = (meta.release_date || '2020').split('-')[0];
        possibleSlugs = [`${cleanTitle}.${year}`, cleanTitle];
    } else {
        // Series Variations:
        // 1. standard.format.s01.e01
        // 2. standard.format (Some APIs just want title and use params)
        // 3. raw-title (hyphens)
        possibleSlugs = [
            `${cleanTitle}.s${pad(s)}.e${pad(e)}`,
            cleanTitle,
            rawTitle.replace(/\s+/g, '-')
        ];
    }

    let streamResult = null;
    let finalSlugUsed = "";

    document.getElementById('loading-text').innerText = "SEARCHING SERVERS...";

    // Try Slugs sequentially
    for (let slug of possibleSlugs) {
        try {
            console.log(`[ENGINE] Attempting Slug: ${slug}`);
            const api = `https://u-1-1azw.onrender.com/api/get-stream?title=${slug}&id=${id}&season=${s}&episode=${e}`;
            const res = await fetch(CONFIG.PROXY(api)).then(r => r.json());
            
            if (res.m3u8_url) {
                streamResult = res;
                finalSlugUsed = slug;
                break; // Found it!
            }
        } catch (e) { console.log(e); }
    }

    if (!streamResult) {
        alert("Server Busy or Source Not Found. Please try again later.");
        loader.style.display = 'none';
        return;
    }

    // --- FETCH SUBTITLES ---
    document.getElementById('loading-text').innerText = "SYNCING SUBTITLES...";
    let subUrl = `https://sub.wyzie.ru/search?id=${id}`;
    if (type === 'tv') subUrl += `&season=${s}&episode=${e}`;
    
    const subtitles = await fetch(CONFIG.PROXY(subUrl)).then(r => r.json()).catch(() => []);

    // Launch Player
    startArtPlayer(CONFIG.PROXY(streamResult.m3u8_url), subtitles, `${id}_${s}_${e}`);
}

/**
 * ============================================================================
 * 4. ARTPLAYER SETUP (The Pro Player)
 * ============================================================================
 */
function startArtPlayer(streamUrl, subs, storageKey) {
    document.getElementById('player-wrapper').style.display = 'flex';
    document.getElementById('dashboard-layer').style.opacity = '0'; // Fade out dashboard

    playerInstance = new Artplayer({
        container: '#artplayer',
        url: streamUrl,
        type: 'm3u8',
        autoplay: true,
        autoPlayback: true,
        fullscreen: true,
        // --- PRO SETTINGS ENABLED ---
        setting: true,
        flip: true,
        playbackRate: true,
        aspectRatio: true,
        subtitleOffset: true,
        miniProgressBar: true,
        
        // Theme
        theme: '#E50914',
        
        // --- CUSTOM LAYERS ---
        layers: [
            // 1. The Red Netflix Spinner inside Player
            {
                name: 'netflix-spinner-layer',
                html: `
                    <div class="nf-spinner-container" style="display:none;">
                        <img src="${CONFIG.SPINNER_IMG}">
                    </div>`
            },
            // 2. Center UI (Play/Pause/Seek)
            {
                name: 'center-controls',
                html: `
                    <div class="art-layer-center-ui">
                        <div class="control-icon" onclick="playerInstance.backward=10">
                            <svg viewBox="0 0 24 24"><path d="M11 18V6l-8.5 6 8.5 6zm.5-6l8.5 6V6l-8.5 6z"/></svg>
                        </div>
                        <div class="control-icon" onclick="playerInstance.toggle()">
                            <svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                        </div>
                        <div class="control-icon" onclick="playerInstance.forward=10">
                            <svg viewBox="0 0 24 24"><path d="M4 18l8.5-6L4 6v12zm9-12v12l8.5-6L13 6z"/></svg>
                        </div>
                    </div>
                `
            },
            // 3. Subtitle Render Box (Visible on Screen)
            {
                name: 'subtitle-renderer',
                html: `<div class="art-layer-subtitle-renderer"><div id="custom-subtitle-text"></div></div>`
            }
        ],

        // --- HLS INTEGRATION (Audio & Quality) ---
        customType: {
            m3u8: function(video, url) {
                if (Hls.isSupported()) {
                    const hls = new Hls();
                    hls.loadSource(url);
                    hls.attachMedia(video);
                    
                    hls.on(Hls.Events.MANIFEST_PARSED, () => {
                        // 1. QUALITY SWITCHER
                        const levels = hls.levels.map((l, i) => ({
                            html: l.height + 'p',
                            level: i
                        }));
                        playerInstance.setting.add({
                            name: 'quality',
                            html: 'Quality',
                            selector: [{html: 'Auto', level: -1, default: true}, ...levels],
                            onSelect: (item) => {
                                hls.currentLevel = item.level;
                                return item.html;
                            }
                        });

                        // 2. AUDIO SWITCHER
                        if (hls.audioTracks.length > 1) {
                            const tracks = hls.audioTracks.map((t, i) => ({
                                html: t.name || t.lang || `Audio ${i+1}`,
                                index: i
                            }));
                            playerInstance.setting.add({
                                name: 'audio',
                                html: 'Audio',
                                selector: tracks,
                                onSelect: (item) => {
                                    hls.audioTrack = item.index;
                                    return item.html;
                                }
                            });
                        }
                    });
                }
            }
        }
    });

    // --- PLAYER EVENTS ---
    playerInstance.on('ready', () => {
        // Resume playback
        const savedTime = localStorage.getItem('resume_' + storageKey);
        if (savedTime) playerInstance.currentTime = parseFloat(savedTime);

        // Add Subtitles to Settings
        if (subs.length > 0) {
            playerInstance.setting.add({
                name: 'subtitle-list',
                html: 'Subtitles',
                selector: [
                    { html: 'Off', url: null, default: true },
                    ...subs.map(s => ({
                        html: s.lang || s.language || 'Unknown',
                        url: CONFIG.PROXY(s.url)
                    }))
                ],
                onSelect: async (item) => {
                    if (!item.url) {
                        subtitleCueList = [];
                        document.getElementById('custom-subtitle-text').style.display = 'none';
                        return 'Off';
                    }
                    
                    // Fetch and Parse VTT
                    const text = await fetch(item.url).then(r => r.text());
                    subtitleCueList = parseVTT(text);
                    document.getElementById('custom-subtitle-text').style.display = 'block';
                    return item.html;
                }
            });
        }
        
        // Hide Loading Screen once video starts
        document.getElementById('loading-overlay').style.display = 'none';
    });

    // Subtitle Sync Logic
    playerInstance.on('video:timeupdate', () => {
        localStorage.setItem('resume_' + storageKey, playerInstance.currentTime);
        
        if (!subtitleCueList.length) return;
        
        // Calculate Time with Offset
        const currentTime = playerInstance.currentTime + (playerInstance.subtitleOffset || 0);
        
        // Find Cue
        const currentCue = subtitleCueList.find(c => currentTime >= c.start && currentTime <= c.end);
        const textBox = document.getElementById('custom-subtitle-text');
        
        if (currentCue) {
            if (currentCue !== activeSubtitleCue) {
                textBox.innerHTML = currentCue.text;
                activeSubtitleCue = currentCue;
            }
        } else {
            textBox.innerHTML = '';
            activeSubtitleCue = null;
        }
    });
    
    // Handle Buffering Spinner
    playerInstance.on('waiting', () => {
        document.querySelector('.art-loading .nf-spinner-container').style.display = 'block';
    });
    playerInstance.on('playing', () => {
        document.querySelector('.art-loading .nf-spinner-container').style.display = 'none';
    });
}

function destroyPlayer() {
    if (playerInstance) playerInstance.destroy();
    document.getElementById('player-wrapper').style.display = 'none';
    document.getElementById('dashboard-layer').style.opacity = '1';
    window.history.pushState({}, '', '/'); // Reset URL
}

// --- UTILS ---
function pad(num) { return num.toString().padStart(2, '0'); }

function parseVTT(vttText) {
    const items = [];
    const lines = vttText.split('\n');
    let current = null;
    
    lines.forEach(line => {
        line = line.trim();
        if (line.includes('-->')) {
            const parts = line.split('-->');
            current = {
                start: timeToSeconds(parts[0]),
                end: timeToSeconds(parts[1]),
                text: []
            };
        } else if (current && line === '') {
            items.push({ ...current, text: current.text.join('<br>') });
            current = null;
        } else if (current) {
            current.text.push(line);
        }
    });
    return items;
}

function timeToSeconds(timeStr) {
    const parts = timeStr.trim().split(':');
    let h = 0, m = 0, s = 0;
    if (parts.length === 3) {
        [h, m, s] = parts;
    } else {
        [m, s] = parts;
    }
    return (parseInt(h) * 3600) + (parseInt(m) * 60) + parseFloat(s);
}
</script>

</body>
</html>
